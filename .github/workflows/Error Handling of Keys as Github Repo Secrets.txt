Problem Summary

Your GitHub Actions workflow uses actions/github-script@v8 to upload Snowflake private keys as repo secrets.
When the API call fails (e.g., encryption or secret upload error), the script does not fail the job—it exits successfully.
This means the workflow reports success even though secrets were not uploaded.


Root Cause
actions/github-script runs JavaScript inside the workflow. If the script does not explicitly throw an error or exit with a non-zero code, GitHub Actions assumes success.
Currently, your script likely:

Logs the error but does not throw it.
Or returns a value without signaling failure.


Goals

Name each step clearly in the job for better traceability.
Stop the workflow and flag errors when API responses indicate failure.
Fix the error in the CA_RADAR workflow.
Use GitHub API correctly for secrets (requires encryption with repo public key).
Optionally make this reusable across projects.


How GitHub Secrets API Works

To create/update a secret:

Get the repo’s public key via GET /repos/{owner}/{repo}/actions/secrets/public-key.
Encrypt your secret using this public key (libsodium).
Send encrypted value via PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}.



If encryption or upload fails, the API returns an error code (e.g., 422 Unprocessable Entity).

Fix Strategy
1. Update Workflow Steps
Example structure for .github/workflows/apply-snowflake-keys.yml:
YAMLjobs:  upload-secrets:    runs-on: ubuntu-latest    steps:      - name: Checkout        uses: actions/checkout@v4      - name: Get GitHub Public Key        id: get-key        uses: actions/github-script@v8        with:          script: |            const response = await github.rest.actions.getRepoPublicKey({              owner: context.repo.owner,              repo: context.repo.repo            });            if (!response.data.key) {              throw new Error("Failed to fetch public key");            }            return response.data;      - name: Encrypt and Upload Secret        id: upload-secret        uses: actions/github-script@v8        with:          script: |            const sodium = require('tweetsodium');            const publicKey = '${{ steps.get-key.outputs.result.key }}';            const keyId = '${{ steps.get-key.outputs.result.key_id }}';            const secretValue = process.env.SNOWFLAKE_PRIVATE_KEY;            if (!secretValue) {              throw new Error("SNOWFLAKE_PRIVATE_KEY is missing");            }            // Encrypt            const messageBytes = Buffer.from(secretValue);            const keyBytes = Buffer.from(publicKey, 'base64');            const encryptedBytes = sodium.seal(messageBytes, keyBytes);            const encryptedValue = Buffer.from(encryptedBytes).toString('base64');            // Upload            try {              await github.rest.actions.createOrUpdateRepoSecret({                owner: context.repo.owner,                repo: context.repo.repo,                secret_name: "SNOWFLAKE_PRIVATE_KEY",                encrypted_value: encryptedValue,                key_id: keyId              });            } catch (error) {              core.setFailed(`Failed to upload secret: ${error.message}`);              throw error; // Ensures workflow fails            }Show more lines
Key Changes

Use throw new Error() or core.setFailed() to fail the step.
Validate inputs before encryption.
Catch API errors and rethrow.


2. Why Current Workflow Shows Success
Your script probably logs errors but does not throw them. GitHub Actions treats any script that finishes without throwing as success.

3. Testing

Create temporary secrets like TEST_SECRET in a test repo.
Delete them after testing using DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}.


4. Reusable Workflow
Once tested, convert this into a reusable workflow:
YAMLworkflow_call:  inputs:    secret_name:      required: true    secret_value:      required: trueShow more lines
Then call it from other repos.
